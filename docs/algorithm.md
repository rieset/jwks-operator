# Алгоритм работы JWKS Operator

## Общий алгоритм реконсиляции

### Фаза 1: Инициализация и получение ресурсов

```
1. Получение JWKSConfig ресурса
   ├─> Если ресурс не найден → завершение (ресурс удален)
   └─> Если найден → продолжение

2. Проверка Finalizer
   ├─> Если ресурс удаляется → обработка удаления
   └─> Если ресурс активен → продолжение

3. Получение связанного Secret
   ├─> Извлечение имени Secret из spec.certificateSecret
   ├─> Получение Secret из Kubernetes API
   └─> Если Secret не найден → ошибка, requeue

4. Валидация Secret
   ├─> Проверка наличия tls.crt
   ├─> Проверка формата сертификата
   └─> Если невалиден → ошибка, requeue
```

### Фаза 2: Генерация JWKS

```
1. Парсинг сертификата
   ├─> Декодирование PEM формата
   ├─> Парсинг X.509 сертификата
   └─> Валидация сертификата

2. Извлечение публичного ключа
   ├─> Определение типа ключа (RSA, ECDSA, etc.)
   ├─> Извлечение ключа из сертификата
   └─> Генерация Key ID (kid)

3. Форматирование JWK
   ├─> Конвертация ключа в JWK формат
   ├─> Добавление метаданных (kty, use, alg, kid)
   ├─> Добавление x5c (certificate chain)
   └─> Добавление x5t и x5t#S256 (thumbprints)

4. Создание JWKS структуры
   ├─> Создание массива keys
   ├─> Добавление нового ключа
   └─> Форматирование в JSON
```

### Фаза 3: Обновление ConfigMap

```
1. Получение текущего ConfigMap
   ├─> Если ConfigMap не существует → создание нового
   └─> Если существует → получение текущего JWKS

2. Определение стратегии обновления
   ├─> Проверка spec.updateStrategy
   ├─> Если "rolling" → graceful rotation
   └─> Если "immediate" → полная замена

3. Применение стратегии обновления
   
   Для "rolling" стратегии:
   ├─> Получение текущего JWKS из ConfigMap
   ├─> Проверка spec.keepOldKeys
   │   ├─> Если true → объединение ключей
   │   └─> Если false → замена ключей
   ├─> Добавление нового ключа в JWKS
   ├─> Удаление устаревших ключей (если TTL истек)
   └─> Обновление ConfigMap
   
   Для "immediate" стратегии:
   ├─> Замена всего JWKS новым
   └─> Обновление ConfigMap

4. Валидация обновления
   ├─> Проверка валидности JSON
   ├─> Проверка структуры JWKS
   └─> Если невалидно → ошибка, откат изменений
```

### Фаза 4: Обновление Nginx Config

```
1. Генерация nginx конфигурации
   ├─> Получение имени JWKS ConfigMap из spec
   ├─> Получение endpoint из spec (или значение по умолчанию)
   │   └─> По умолчанию: `/jwks.json` (используется для обратной совместимости, но не влияет на конфигурацию)
   └─> Генерация nginx конфигурации с `location /` для обслуживания всех путей

2. Создание nginx конфигурации
   ├─> Настройка server block
   ├─> Настройка location block `location /` с `try_files` для обслуживания всех путей
   ├─> Указание пути к JWKS файлу из ConfigMap
   │   └─> `/usr/share/nginx/html/jwks.json`
   └─> Настройка заголовков (Content-Type: application/json, CORS, Cache-Control)

3. Обновление nginx ConfigMap
   ├─> Получение текущего nginx ConfigMap (если существует)
   ├─> Сравнение с новой конфигурацией
   ├─> Если изменилась → обновление ConfigMap
   └─> Если не изменилась → пропуск обновления

4. Создание/обновление nginx Deployment
   ├─> Проверка существования Deployment (имя совпадает с именем JWKS ресурса)
   ├─> Создание или обновление Deployment с nginx контейнером
   ├─> Настройка volumes для nginx конфигурации и JWKS данных
   └─> Настройка ресурсов контейнера из конфигурации

5. Создание/обновление nginx Service
   ├─> Проверка существования Service (имя совпадает с именем JWKS ресурса)
   ├─> Создание или обновление ClusterIP Service
   └─> Настройка селекторов для связи с nginx Deployment
```

### Фаза 5: Обновление статуса

```
1. Обновление условий (Conditions)
   ├─> Установка Ready condition в True
   ├─> Запись времени последнего обновления
   └─> Очистка старых ошибок (если успешно)

2. Запись метаданных
   ├─> LastUpdateTime → текущее время
   ├─> LastKeyID → kid нового ключа
   ├─> KeyCount → количество ключей в JWKS
   └─> NginxConfigUpdated → время обновления nginx config

3. Сохранение статуса
   ├─> Обновление JWKSConfig ресурса
   └─> Если ошибка → запись в status.conditions
```

## Алгоритм Graceful Rotation

### Цель

Обеспечить непрерывную работу системы во время ротации ключей, позволяя:
- Новым токенам подписываться новым ключом
- Старым токенам верифицироваться старым ключом

### Процесс

```
1. Обнаружение нового сертификата
   ├─> Cert-manager создает новый сертификат
   ├─> Secret обновляется с новым tls.crt
   └─> Operator обнаруживает изменение

2. Генерация нового ключа
   ├─> Извлечение публичного ключа из нового сертификата
   ├─> Генерация нового kid (отличается от старого)
   └─> Создание нового JWK entry

3. Объединение ключей
   ├─> Получение текущего JWKS из ConfigMap
   ├─> Проверка spec.keepOldKeys
   │   ├─> Если true:
   │   │   ├─> Добавление нового ключа в массив keys
   │   │   ├─> Сохранение старых ключей
   │   │   └─> Обновление ConfigMap
   │   └─> Если false:
   │       └─> Замена старого ключа новым
   └─> Обновление ConfigMap

4. Период сосуществования
   ├─> Новые токены подписываются новым ключом (новый kid)
   ├─> Старые токены верифицируются старым ключом (старый kid)
   └─> Оба ключа доступны в JWKS endpoint

5. Удаление старых ключей
   ├─> Проверка TTL старых ключей (spec.oldKeysTTL)
   ├─> Если TTL истек:
   │   ├─> Удаление старых ключей из JWKS
   │   └─> Обновление ConfigMap
   └─> Если TTL не истек:
       └─> Сохранение ключей до истечения TTL
```

### Временная диаграмма

```
Время:     T0          T1          T2          T3
          │           │           │           │
Сертификат: [Старый]  [Новый]     [Новый]     [Новый]
          │           │           │           │
JWKS:     [Key1]     [Key1,Key2] [Key1,Key2] [Key2]
          │           │           │           │
Токены:   [Token1]    [Token1,Token2] [Token2] [Token2]
          │           │           │           │
          │           │           │           │
          └───────────┴───────────┴───────────┘
          Создание    Период      Удаление
          нового      сосуществования старого
          ключа                    ключа
          
T0: Старый сертификат активен
T1: Новый сертификат создан, оба ключа в JWKS
T2: Период сосуществования (обычно 30 дней)
T3: Старый ключ удален, только новый активен
```

## Алгоритм обработки ошибок

### Типы ошибок

1. **Временные ошибки** (retryable)
   - Ошибки сети
   - Временная недоступность API
   - Rate limiting

2. **Постоянные ошибки** (non-retryable)
   - Невалидный сертификат
   - Неправильная конфигурация
   - Отсутствие прав доступа

### Обработка

```
1. Определение типа ошибки
   ├─> Если временная → requeue с задержкой
   └─> Если постоянная → запись в статус, не requeue

2. Для временных ошибок
   ├─> Увеличение счетчика попыток
   ├─> Экспоненциальная задержка
   │   ├─> Попытка 1: 5 секунд
   │   ├─> Попытка 2: 10 секунд
   │   ├─> Попытка 3: 20 секунд
   │   └─> Максимум: 5 минут
   └─> Requeue с задержкой

3. Для постоянных ошибок
   ├─> Запись ошибки в status.conditions
   ├─> Установка Ready condition в False
   ├─> Логирование ошибки
   └─> Не requeue (требуется ручное вмешательство)

4. После успешного исправления
   ├─> Очистка ошибок из статуса
   ├─> Установка Ready condition в True
   └─> Продолжение нормальной работы
```

## Алгоритм обработки удаления

### Процесс удаления JWKSConfig

```
1. Обнаружение удаления
   ├─> Kubernetes отправляет событие удаления
   └─> Finalizer предотвращает немедленное удаление

2. Очистка ресурсов
   ├─> Удаление ConfigMap (если spec.cleanupOnDelete = true)
   ├─> Удаление связанных ресурсов
   └─> Логирование операции удаления

3. Удаление Finalizer
   ├─> Удаление finalizer из метаданных
   └─> Обновление ресурса (разрешает удаление)

4. Завершение
   └─> Kubernetes завершает удаление ресурса
```

## Оптимизации алгоритма

### Кэширование

```
1. Кэширование текущего JWKS
   ├─> Хранение последнего JWKS в памяти
   ├─> Сравнение с новым перед обновлением
   └─> Пропуск обновления если не изменилось

2. Кэширование сертификатов
   ├─> Хранение последнего сертификата
   ├─> Сравнение fingerprint перед парсингом
   └─> Пропуск генерации если сертификат не изменился
```

### Rate Limiting

```
1. Ограничение частоты обновлений
   ├─> Максимум 1 обновление ConfigMap в минуту
   ├─> Очередь обновлений для множественных изменений
   └─> Батчинг обновлений при множественных изменениях

2. Ограничение реконсиляций
   ├─> Минимальный интервал между реконсиляциями: 5 секунд
   ├─> Максимальная частота: 12 реконсиляций в минуту
   └─> Экспоненциальная задержка при ошибках
```

## Последовательность операций (Sequence Diagram)

```
Cert-Manager          Operator              Secret           ConfigMap
     │                    │                    │                 │
     │──Create Cert──────>│                    │                 │
     │                    │                    │                 │
     │                    │──Update Secret────>│                 │
     │                    │                    │                 │
     │                    │<──Get Secret───────│                 │
     │                    │                    │                 │
     │                    │──Parse Cert────────│                 │
     │                    │──Generate JWKS────│                 │
     │                    │                    │                 │
     │                    │<──Get ConfigMap────┼─────────────────┤
     │                    │                    │                 │
     │                    │──Merge Keys────────│                 │
     │                    │                    │                 │
     │                    │──Update ConfigMap──┼────────────────>│
     │                    │                    │                 │
     │                    │──Update Status─────│                 │
     │                    │                    │                 │
```

## Псевдокод основного алгоритма

```go
func Reconcile(ctx context.Context, req Request) (Result, error) {
    // Фаза 1: Получение ресурсов
    jwksConfig := getJWKSConfig(req)
    if jwksConfig == nil {
        return Done, nil // Ресурс удален
    }
    
    secret := getSecret(jwksConfig.Spec.CertificateSecret)
    if secret == nil {
        return Requeue, error("Secret not found")
    }
    
    // Фаза 2: Генерация JWKS
    cert := parseCertificate(secret.Data["tls.crt"])
    publicKey := extractPublicKey(cert)
    kid := generateKeyID(cert)
    newJWK := formatJWK(publicKey, kid)
    newJWKS := createJWKS(newJWK)
    
    // Фаза 3: Обновление ConfigMap
    currentJWKS := getCurrentJWKS(jwksConfig.Spec.ConfigMapName)
    
    if shouldKeepOldKeys(jwksConfig) {
        mergedJWKS := mergeJWKS(currentJWKS, newJWKS)
        removeExpiredKeys(mergedJWKS, jwksConfig.Spec.OldKeysTTL)
        updateConfigMap(mergedJWKS)
    } else {
        updateConfigMap(newJWKS)
    }
    
   // Фаза 4: Обновление Nginx Config и создание Deployment/Service
   endpoint := getEndpoint(jwksConfig) // По умолчанию: "/jwks.json" (для обратной совместимости)
   nginxConfig := generateNginxConfig(jwksConfig.Spec.ConfigMapName, endpoint)
   updateNginxConfigMap(jwksConfig.Spec.NginxConfigMapName, nginxConfig)
   
   // Создание/обновление nginx Deployment
   ensureNginxDeployment(jwksConfig.Name, nginxConfigMapName, jwksConfig.Spec.ConfigMapName, nginxResources)
   
   // Создание/обновление nginx Service
   ensureNginxService(jwksConfig.Name)
    
    // Фаза 5: Обновление статуса
    updateStatus(jwksConfig, Status{
        Ready: true,
        LastUpdateTime: now(),
        LastKeyID: kid,
    })
    
    return Done, nil
}
```

